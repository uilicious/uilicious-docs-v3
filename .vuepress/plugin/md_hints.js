/*************************************************************************************************
 * 
 * markdown-it plugin function, which will add {% hint %} and {% endhint %} blocks support.
 * 
 *************************************************************************************************/

//--------------------------------------------------------------------------------------------
//
// NOTE: Due to the incredible lack of documentation on how to write a markdown-it plugin
//       code commentry here will be extreamly verbose, to better aid future plugin authors.
//
//       In addition variable naming favours generic discriptions, over multiple potential 
//       use cases (instead of being specific for our use case), to help make the 
//       "aha" moment easier for another author.
//
//       Code ordering is also structured, to make things easier to understand
//       (eg: the module.exports is brought forward instead of being placed last normally)
//
//       Do not treat any guidance here as definitive, I do not represent markdown-it.
//       I am simply guessing, by trial and error & research, to provide something more
//       informative then "try and fork other plugins", for how to make your own plugin.
//
//       See: https://github.com/markdown-it/markdown-it/blob/master/docs/development.md
//
//       In general for a large 99% percentage of use cases, you might find it "easier" 
//       to build ontop of plugin builders, which greatly simplify the process.
//       
//       Eg: https://www.npmjs.com/package/markdown-it-container
//
//       However if your use does not fit one of the existing "plugin builders", you
//       will have to write effectively your own token parser. Which because its "hard"
//       this verbose documentation, is here to help you in making your own plugin.
//
//--------------------------------------------------------------------------------------------

//
// md : is the markdown-it instance
//
// In general most plugin are initialized by calling the function, and providing the
// markdown-it instance. By design the plugin should not require a dependency on md-it
// as this instance will be passed into the plugin
//
// For example in vuepress 2 it would be something like the following in config.js
// ```
// { 
//    ... // other config.js stuff
//    extendsMarkdown: (md) => {
//	    require("custom/md-it/plugin")(md, pluginOptions);
//    },
//    ...
// }
// ```
//
// For example with markdown-it directly
//
// ```
// var md = require('markdown-it')();
// md.use( require("custom/md-it/plugin"), pluginOptions);
// ```
//
module.exports = (md, pluginOptions) => {

	// md.block.ruler.before : this register the plugin hook into markdown-it
	//
	// Firstly you have to understand that md-it, does not use an AST tokenizer
	// this is intentional as due to how the "markdown" language is designed, the
	// AST tokenizer can be "overkill" and hard to extend
	//
	// If you do not know whats an AST, its ok, its a complex tool we use to 
	// to very commonly process most programming language
	//
	// In general its easier to view this as a set of really optimized what could have
	// been functions with "regex-like-rules" that was executed line by line
	//
	md.block.ruler.before(
		// "fence" refers to the markdown-it stage before code blocks are processed
		// plugins generally hook into before this stage, for some reasons (dunno)
		//
		// see : https://github.com/markdown-it/markdown-it/issues/289
		// for the full list of ruler stages
		//
		// If you want to only do processing after some of the first few items are processed
		// you can opt for an alternative stage of the process.
		"fence", 
		// What we name our plugin : hintblock
		"hintblock", 
		// The plugin function that is triggered
		hintblockPlugin, 
		// I have no idea why almost every plugin does this
		{ alt: ["paragraph", "reference", "blockquote", "list"] }
	);
	
	// This is the renderer, to process the blocks generated by the plugin
	md.renderer.rules.hintblock = hintblockRender;
}

//
// In general the plugin function seems to be called once for ever line of the markdown file
// that is not empty whitespace. Or is not "taken by another plugin" function
// (for lack of better words)
//
// These are sometime called "ruler plugins" as the manager for it is called a "ruler"
// (according to the markdown-it docs), to avoid confusion with the "render" plugin (later).
// 
// So very vaguely you can think of the following occuring, when the ruler plugin is called
// for every markdown file.
//
// (the following is definately wrong, actual code is way more complicated,
//  as various plugins can modify the state, recursion, etc. But it gives a good
//  enough idea on how it would work for most plugins)
//
// ```
// let state = { ... state object with various things ... }
// let mdContent = "... raw content from str ..."
//
// // Lets set the state src value
// state.src = mdContent;
//
// // The number of lines to update
// let mdContentArr = mdContent.split("\n");
// let endLine = mdContentArr.length;
//
// // Iterating each line
// for(let startLine=0; startLine<endLine; startLine++) {
//
//    // Skip blank lines
//    if( mdContentArr[startLine].trim() == "" ) {
//      continue;  
//    }
//
//    // Call the various plugins, including this function,
//    // we will cover silent mode later
//    ruler.callAllThePlugins( state, startLine, endLine )    
//
//    // Does various complex things to modify the state obj, etc
//    ....
// }
// ```
/**
 * Plugin function for the md-it "ruler" operations
 * 
 * @param {Object}  state obj representing the current markdown process/file
 * @param {int}     startLine number of the line being processed
 * @param {int}     lastLine number of the "file" (or string) being processed
 * @param {boolean} silentValidation flag, if true, function should only return true, or false
 *                  only if it have a relevent starting token. It must not modify if silent.
 *                  (example of how this flag is used is in the function)
 **/
function hintblockPlugin(state, startLine, endLine, silentValidation) {

	//---------------------------------------------------------------------------------------
	//
	// ## Find out where your line starts (or ends)
	//
	// First, given the startLine, we should extract out the
	// starting character number, and ending character number of the line
	//
	// This can be done using the following values prepopulated by md-it
	//
	// state.bMarks[lineNum] : Character number of "start of line"
	// state.eMarks[lineNum] : Character number of "ending of line"
	// state.tShift[lineNum] : Offset from bMarks, to the first non white-space character,
	//                         this is useful, if your content uses the prefix whitespace
	//                         as some indicator of "level" or "hirachy", if not for most,
	//                         you will add this together with "start of line" value
	//
	//---------------------------------------------------------------------------------------
	let startOfLine = state.bMarks[startLine] + state.tShift[startLine];
	let endinOfLine = state.eMarks[startLine];

	//---------------------------------------------------------------------------------------
	//
	// ## Early return false when possible (or markdown-it will be ssslllooowww...)
	//
	// Typically for "performance", you try to return `false` as soon as possible
	// if you are certain the line does not contain anything relevent to your plugin.
	//
	// In this stage when possible, we avoid heavy regex, and "slicing" for the line
	// string, until we have some indicator that we found a match.
	//
	//---------------------------------------------------------------------------------------

	// For example, we know that "{%", and "%}" is our opening and closing tag for our use case
	// So, lets get the chracter numbers for them, so we can check for them efficently
	//
	// `"{%".charCodeAt(0)`, gives 123
	// `"{%".charCodeAt(1)`, gives 37
	const openChar1 = 123; 
	const openChar2 = 37; 

	// ---
	// IF: your plugin is designed to be only the start of a new line, you can fail quickly
	//     if the desired character is not at the start of the line, return false on the spot.
	//     
	//     However this is not the case for us as of now
	// ---
	// // If it does not match, return false
	// if( state.src.charCodeAt(start) != openChar1 ) {
	//     return false;
	// }
	// ---

	// So alternatively, we scan the line character by character with the startPos var,
	// which we will use this for tracking "start of block"
	let startPos;

	// We use lastCheckingPos, instead of endinOfline, because at minimum we would need to 
	// match against "{% hint %}", or 10 characters in total.
	//
	// For our use case, we do not allow this block to be split across multiple lines, 
	// if you do so for yours, you may want to check only for the starting 2 characters only. 
	// 
	// If your use case uses a block of only 1 character, its generally considered "bad design"
	// due to the high possibility of triggering it in normal valid text.
	//
	// In our case, if the first of the last 10 character is not a valid match, 
	// we do not need to check against all other remiaing 9 characters.
	let lastValidStartPos = endinOfLine - 10;

	// Note that if lastValidStartPos is < startOfLine (less then 10 characters)
	// it means the line is less then 10 characters, so lets ignore this line for our use case.
	if( lastValidStartPos <= startPos ) {
		return false;
	}

	// Lets loop for each character one-by-one
	for(startPos=startOfLine; startPos<=lastValidStartPos; ++startPos) {
		if( state.src.charCodeAt(startPos) === openChar1 ) {
			break;
		}
	}

	// If startPos is not found within the lastValidStartPos bound. Its either not on the current line at all,
	// or the opening character "{" is in the last 9 characters, and might mean something else and is not 
	// relevent for our use case.
	//
	// If startPos <= lastValidStartPos, a match is found
	if( startPos > lastValidStartPos ) {
		return false;
	}

	// ---
	// Minor note: The additional 2nd / 3rd char check is not really needed, im just obsessive. 
	//             Most plugin's I seen stop optimizing their early false return with the first
	//             1 or 2 characters as its typically "good enough" I guess  ¯\(o_o)/¯
	// ---

	// Lets check the 2nd character, and fail that quickly too if possible
	if( state.src.charCodeAt(startPos+1) !== openChar2 ) {
		return false;
	}

	// Lets get the markdown instance
	const md = state.md;

	// Lets check that the 3rd character, for whitespace (for our use case)
	// to avoid needing to figure out the various UTF-8 implemention of whitespaces
	// you can use the provided `md.utils.isWhitespace(charCode)` tool
	if( md.utils.isWhiteSpace( state.src.charCodeAt(startPos+2) ) === false ) {
		return false;
	}

	//---------------------------------------------------------------------------------------
	//
	// ## Lets process the opening line (more casually)
	//
	// Now that we have optimized quick returns in the above, you can now start
	// processing the strings, without the obsession in performance. 
	// (I prefer to make code readable as much as possible)
	//
	// We can be somewhat confident that anything past this line, has a resonably chance
	// of being part of our use case.
	//
	// However, as it is still possible for the line to be not relevent for our use case, 
	// as such we should code defensively to account for such flows.
	//
	//---------------------------------------------------------------------------------------

	// You can get the full line from the first non-whitespace character with the following
	// --- 
	// let markdownLine = state.src.slice(startOfLine, endinOfLine);

	// However we can also opt for a more truncated string (without the opening "{%")
	let markdownLine = state.src.slice(startPos+3, endinOfLine)

	// Let me setup the opening and closing tokens
	const open = "{%"
	const close = "%}"

	// Lets check for closing token, if its not found. We return false once again
	let closeTokenOffset = markdownLine.indexOf(close);
	if( closeTokenOffset <= 0 ) {
		// No match, exit
		return false;
	}

	// Ok we finally found a valid starting and closing pair, 
	// lets get the opening block inner string
	let openBlockStr = markdownLine.slice(0, closeTokenOffset).trim();

	// While our blocks can support multiple parameters
	// what is more critical is that our first word starts with "hint" for our use case
	let openBlockArr = openBlockStr.split(/[\s]+/);
	if( openBlockArr[0].toLowerCase() !== "hint" ) {
		return false;
	}

	//---------------------------------------------------------------------------------------
	//
	// ## Lock in, and handle silent flag
	//
	// Now that we are absolutely sure that the line presented to us is relevent.
	// with proper opening and closing bracker for the opening block.
	//
	// We will report success, if the silentValidation flag is set to true.
	//
	// Assumingly, after reporting true, the function will be called again to perform
	// the actual state processing. And only then will we be allowed to modify states.
	//
	//---------------------------------------------------------------------------------------

	// Exit with success, if its in silent validation mode.
	if( silentValidation ) {
		return true;
	}

	// lets compute the closeTokenPos
	let closeTokenPos = startPos+3+closeTokenPos;
	


	return false;
}

function hintblockRender(tokens, idx, options, env, slf) {
	return '<summary><span class="details-marker">&nbsp;</span>' + slf.renderInline(tokens[idx].children, options, env) + "</summary>";
}