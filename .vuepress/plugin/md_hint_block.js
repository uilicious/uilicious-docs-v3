/*************************************************************************************************
 * 
 * markdown-it plugin function, which will add {% hint %} and {% endhint %} blocks support.
 * 
 *************************************************************************************************/

//--------------------------------------------------------------------------------------------
//
// NOTE: Due to the incredible lack of documentation on how to write a markdown-it plugin,
//       code commentry here will be extreamly verbose, to better aid future plugin authors.
//
//       In addition variable naming favours generic discriptions, over multiple potential 
//       use cases (instead of being specific for our use case), to help make the 
//       "aha" moment easier for another author.
//
//       Code ordering is also structured, to make things easier to understand
//       (eg: the module.exports is brought forward instead of being placed last normally)
//
//       Do not treat any guidance here as definitive, I do not represent markdown-it.
//       I am simply guessing, by trial and error & research, to provide something more
//       informative then "try and fork other plugins", for how to make your own plugin.
//
//       See: https://github.com/markdown-it/markdown-it/blob/master/docs/development.md
//
//       In general for a large 99% percentage of use cases, you might find it "easier" 
//       to build ontop of plugin builders, which greatly simplify the process.
//       
//       So please consider using one of the following when possible
//       - https://www.npmjs.com/package/markdown-it-container
//       - https://www.npmjs.com/package/markdown-it-custom-block
//
//       However if your use case does not fit one of the existing "plugin builders", and
//       you have to write effectively your own token parser (which is "hard").
//       This verbose documentation, is here to help you in making your own plugin.
//       (hopefully, or whoever in the future needs to maintain my plugin code)
//
//--------------------------------------------------------------------------------------------

//
// md : is the markdown-it instance
//
// In general most plugin are initialized by calling the function, and providing the
// markdown-it instance. By design the plugin should not require a dependency on md-it
// as this instance will be passed into the plugin
//
// For example in vuepress 2 it would be something like the following in config.js
// ```
// { 
//    ... // other config.js stuff
//    extendsMarkdown: (md) => {
//	    require("custom/md-it/plugin")(md, pluginOptions);
//    },
//    ...
// }
// ```
//
// For example with markdown-it directly
//
// ```
// var md = require('markdown-it')();
// md.use( require("custom/md-it/plugin"), pluginOptions);
// ```
//
module.exports = (md, pluginOptions) => {

	// md.block.ruler.before : this register the plugin hook into markdown-it
	//
	// Firstly you have to understand that md-it, does not use an AST tokenizer
	// this is intentional as due to how the "markdown" language is designed, the
	// AST tokenizer can be "overkill" and hard to extend (agreed)
	//
	// If you do not know whats an AST, its alright, its a complex tool we use to 
	// to very commonly process most programming language. And we are not using it.
	//
	// In general its easier to view this as a set of really optimized what could have
	// been functions with "regex-like-rules" that was executed line by line.
	// (hopefully this analogy make sense in time)
	//
	md.block.ruler.before(
		// "fence" refers to the markdown-it stage before code blocks are processed
		// many plugins generally hook into before this stage, for some reasons (dunno)
		//
		// see : https://github.com/markdown-it/markdown-it/issues/289
		// for the full list of ruler stages
		//
		// If you want to only do processing after some of the first few stages are processed
		// you can opt for an alternative stage of the process. I suspect this might have been
		// a case of if it aint broke, everyone just kept copy and pasting this stage.
		"fence", 
		// What we name our plugin : hintblock
		"hintblock", 
		// The plugin function that is triggered
		hintblockPlugin, 
		// I have no idea why almost every plugin does this
		// same as stage, im reusing it.
		{ alt: ["paragraph", "reference", "blockquote", "list"] }
	);
	
	//
	// Setup the renderer, to process the tokens generated by the plugin
	// In our example, we will generate 3 tokens, named "hintblock_open", 
	// "hintblock_body", "hintblock_close". 
	//
	// It is not required to have all 3 renderers. 
	// (more on this later)
	//
	md.renderer.rules.hintblock_open  = hintblockRender;
	md.renderer.rules.hintblock_body  = hintblockRender;
	md.renderer.rules.hintblock_close = hintblockRender;
}

//
// In general the plugin function seems to be called once for ever line of the markdown file
// that is not empty whitespace. Or is not "taken by another plugin" function
// (for lack of better words)
//
// These plugin functions are also called "ruler plugins" as the manager for it is called a "ruler"
// (according to the markdown-it docs), to avoid confusion with the "render" plugin (later).
//
// The ruler, and its plugins are suppose to take the markdown string, and convert it into
// "tokens" (similar to AST), these tokens are then converted into the rendered HTML with the
// "render" plugin functions.
// 
// So very vaguely you can think of the following loop occuring, when the ruler plugin is called
// for every markdown file. To get the rough idea whats going on for now.
//
// (the following is definately wrong, actual code is way more complicated,
//  as various plugins can modify the state, do recursion, etc. But it gives a good
//  enough idea on how it would work for most plugins, from their limited point of view)
//
// ```
// let state = { ... state object with various things ... }
// let mdContent = "... raw content from str ..."
//
// // Lets set the state src value
// state.src = mdContent;
//
// // The number of lines to update
// let mdContentArr = mdContent.split("\n");
// let endLine = mdContentArr.length;
//
// // Final block output
// let blockOutput = [];
//
// // Iterating each line
// for(let startLine=0; startLine<endLine; startLine++) {
//
//    // Skip blank lines
//    if( mdContentArr[startLine].trim() == "" ) {
//      continue;  
//    }
//
//    // Call the various plugins, including this function,
//    // we will cover silent mode later
//    blockOutput = ruler.callAllThePlugins( state, startLine, endLine )    
//
//    // Does various complex things to modify the state obj, etc
//    ....
// }
//
// // Convert the blockOutput, into the HTML string
// return renderer.allAllThePlugins( blockOutput );
//
// ```
/**
 * Plugin function for the md-it "ruler" operations
 * 
 * @param {Object}  state obj representing the current markdown process/file
 * @param {int}     startLine number of the line being processed
 * @param {int}     endLine number of the "file" (or string) being processed
 * @param {boolean} silentValidation flag, if true, function should only return true, or false
 *                  only if it have a relevent starting token. It must not modify if silent.
 *                  (example of how this flag is used is in the function)
 **/
function hintblockPlugin(state, startLine, endLine, silentValidation) {

	//---------------------------------------------------------------------------------------
	//
	// ## Find out where your line starts (or ends)
	//
	// First, given the startLine, we should extract out the
	// starting character number, and ending character number of the line
	//
	// This can be done using the following values prepopulated by md-it
	//
	// state.bMarks[lineNum] : Character number of "start of line"
	// state.eMarks[lineNum] : Character number of "ending of line"
	// state.tShift[lineNum] : Offset from bMarks, to the first non white-space character,
	//                         this is useful, if your content uses the prefix whitespace
	//                         as some indicator of "level" or "hirachy", if not for most,
	//                         you will add this together with "start of line" value
	//
	//---------------------------------------------------------------------------------------
	let startOfLine = state.bMarks[startLine] + state.tShift[startLine];
	let endinOfLine = state.eMarks[startLine];

	//---------------------------------------------------------------------------------------
	//
	// ## Early return false when possible (or markdown-it will be ssslllooowww...)
	//
	// Typically for "performance", you try to return `false` as soon as possible
	// if you are certain the line does not contain anything relevent to your plugin.
	//
	// In this stage when possible, we avoid heavy regex, and "slicing" for the line
	// string, until we have some indicator that we found a match.
	//
	//---------------------------------------------------------------------------------------

	// For example, we know that "{%", and "%}" is our opening and closing tag for our use case
	// So, lets get the chracter numbers for them, so we can check for them efficently
	//
	// `"{%".charCodeAt(0)`, gives 123
	// `"{%".charCodeAt(1)`, gives 37
	const openChar1 = 123; 
	const openChar2 = 37; 

	// ---
	// IF: your plugin is designed to be only the start of a new line, you can fail quickly
	//     if the desired character is not at the start of the line, return false on the spot.
	//     
	//     However this is not the case for us as of now
	// ---
	// // If it does not match, return false
	// if( state.src.charCodeAt(start) != openChar1 ) {
	//     return false;
	// }
	// ---

	// So alternatively, we scan the line character by character with the openBlockStartPos var,
	// which we will use this for tracking "start of block"
	let openBlockStartPos;

	// We use lastCheckingPos, instead of endinOfline, because at minimum we would need to 
	// match against "{% hint %}", or 10 characters in total.
	//
	// For our use case, we do not allow this block to be split across multiple lines, 
	// if you do so for yours, you may want to check only for the starting 2 characters only. 
	// 
	// If your use case uses a block of only 1 character, its generally considered "bad design"
	// due to the high possibility of triggering it in normal valid text.
	//
	// In our case, if the first of the last 10 character is not a valid match, 
	// we do not need to check against all other remiaing 9 characters.
	let lastValidStartPos = endinOfLine - 10;

	// Note that if lastValidStartPos is < startOfLine (less then 10 characters)
	// it means the line is less then 10 characters, so lets ignore this line for our use case.
	if( lastValidStartPos <= openBlockStartPos ) {
		return false;
	}

	// Lets loop for each character one-by-one
	for(openBlockStartPos=startOfLine; openBlockStartPos<=lastValidStartPos; ++openBlockStartPos) {
		if( state.src.charCodeAt(openBlockStartPos) === openChar1 ) {
			break;
		}
	}

	// If openBlockStartPos is not found within the lastValidStartPos bound. Its either not on the current line at all,
	// or the opening character "{" is in the last 9 characters, and might mean something else and is not 
	// relevent for our use case.
	//
	// If openBlockStartPos <= lastValidStartPos, a match is found
	if( openBlockStartPos > lastValidStartPos ) {
		return false;
	}

	// ---
	// Minor note: The additional 2nd / 3rd char check is not really needed, im just obsessive. 
	//             Most plugin's I seen stop optimizing their early false return with the first
	//             1 or 2 characters as its typically "good enough" I guess  ¯\(o_o)/¯
	//
	//             Its also a good excuse for me to use the md.utils (which is useful to some ppl)
	// ---

	// Lets check the 2nd character, and fail that quickly too if possible
	if( state.src.charCodeAt(openBlockStartPos+1) !== openChar2 ) {
		return false;
	}

	// Lets get the markdown instance
	const md = state.md;

	//
	// Lets check that the 3rd character, for whitespace (for our use case)
	// to avoid needing to figure out the various UTF-8 implemention of whitespaces
	// you can use the provided `md.utils.isWhitespace(charCode)` tool
	//
	// You can find the commands here
	// See: https://github.com/markdown-it/markdown-it/blob/a1c9381/lib/common/utils.js
	//
	// There are also other useful commands on the state object itself here
	// See: https://github.com/markdown-it/markdown-it/blob/a1c9381/lib/rules_block/state_block.js
	//
	if( md.utils.isWhiteSpace( state.src.charCodeAt(openBlockStartPos+2) ) === false ) {
		return false;
	}

	//---------------------------------------------------------------------------------------
	//
	// ## Lets process the opening line (more casually)
	//
	// Now that we have optimized quick false returns in the above, you can now start
	// processing the strings, without the obsession in performance. 
	// (I prefer to make code readable as much as possible)
	//
	// We can be somewhat confident that anything past this line, has a resonably chance
	// of being part of our use case.
	//
	// However, as it is still possible for the line to be not relevent for our use case, 
	// as such we should code defensively to account for such flows.
	//
	//---------------------------------------------------------------------------------------

	// You can get the full line from the first non-whitespace character with the following
	// --- 
	// let markdownLine = state.src.slice(startOfLine, endinOfLine);

	// However we can also opt for a more truncated string (without the opening "{%")
	let markdownLine = state.src.slice(openBlockStartPos+3, endinOfLine)

	// Let's define the opening and closing tokens strings
	// this is used for both the "opening block" and the "closing block"
	// which is "{% hint %}" and "{% endhint %}" respectively
	const openBlock = "{%"
	const closeBracket = "%}"

	// Lets check for closing token, if its not found. We return false once again
	let openBlockCloseTokenOffset = markdownLine.indexOf(closeBracket);
	if( openBlockCloseTokenOffset <= 0 ) {
		// No match, exit
		return false;
	}

	// Ok we finally found a valid starting and closing pair, 
	// lets get the opening block inner string
	let openBlockStr = markdownLine.slice(0, openBlockCloseTokenOffset).trim();

	// While our blocks can support multiple parameters
	// what is more critical is that our first word starts with "hint" for our use case
	let openBlockArr = openBlockStr.split(/[\s]+/);
	if( openBlockArr[0].toLowerCase() !== "hint" ) {
		return false;
	}

	//---------------------------------------------------------------------------------------
	//
	// ## Lock in, and handle silent flag
	//
	// Now that we are absolutely sure that the line presented to us is relevent.
	// with proper opening and closing bracker for the opening block.
	//
	// We will report success, if the silentValidation flag is set to true.
	//
	// Assumingly, after reporting true, the function will be called again to perform
	// the actual state processing. And only then will we be allowed to modify states.
	//
	// Some plugin documentation seems to imply supporting this is optional
	// but I could not find any means, to safely "not support" this behaviour.
	//
	// So make sure to add the check i suppose.
	//
	// ¯\(o_o)/¯
	//
	//---------------------------------------------------------------------------------------

	// Exit with success, if its in silent validation mode.
	// Everything after here will involve state manipulation
	if( silentValidation ) {
		return true;
	}

	// lets compute the openBlockCloseTokenPos, for the "%" character in the opening "%}" block
	let openBlockCloseTokenPos = openBlockStartPos+3+openBlockCloseTokenOffset;

	// and the open block ending pos (after the %} characters)
	let openBlockEndinPos = openBlockCloseTokenPos+2;
	
	//---------------------------------------------------------------------------------------
	//
	// ## Find the closing block set 
	//
	// Lets find the closing block set, if its not found, we will presumingly just
	// use all remaining lines as the "summary" block between the opening and closing.
	//
	//---------------------------------------------------------------------------------------

	// ---
	// NOTE: how to deal with the closing block search is very "use case sensitive"
	//
	//       There is a resonable chance the logic here does not fit your use case.
	//       if so, figure out how to get the closing block position "on your own",
	//       and use this codebase as a refrence on what to do after that.
	// ---

	//
	// Closing block regex, this is used to find our {% endhint %} block
	//
	// /                     # - Start of regex
	// (                     # - Opening capture group 1
	//   \{\%                # - Match "{%"
	//   [\s]+               # - Match any number of white space
	//   endhint             # - Match "endhint " including an ending whitespace
	//   [\s]+               # - Match any number of white space
	//   [.]*                # - Match any random parameters which would ignore
	//                       #   ( Eg: "param=xyz %}" )
	//   \%\}                # - Match "%}" 
	// )                     # - Closing capture group 1
	// /img                  # - End of regex, indicated as case insensitive, 
	//                       #   multi-line, and global match
	//
	const closeBlockRegex = /(\{\%[\s]+endhint[\s]+[.]*\%\})/img;

	// ---
	// I added the following "nextLine" loop here, as a large number of plugin's performs this
	// action in one way or another, due to the requirements of their use case.
	//
	// This might be useful for you, if needed. It isn't in my current use case.
	// ---
	/***
	// Lets start iterating all the lines from here onwards hopefully its in an early line block
	let nextLine = startLine;
	for(nextLine; nextLine < endLine; nextLine++) {

		// Lets get start and max of line
		let start = state.bMarks[nextLine] + state.tShift[nextLine];
		let max = state.eMarks[nextLine];

		// Lets skip to "after" the current block for first line
		//
		// this makes sense for oru use case, it may not make sense for use cases
		// where multiple lines is a gurantee.
		if( nextLine == startLine ) {
			start = openBlockEndinPos;
		}

		// Get the line string, if possible code your check to avoid this 
		// (slice in a loop is expensive)
		let lineStr = state.src.slice(start, max)

		// .... Do matching logic ???
		let match = lineStr.match( closeBlockRegex )

		// .... More matching logic ???
	}
	***/

	// ---
	// Instead I opt to do the following with RegExp
	// ---

	// Modify the RegExp "lastIndex", to begin a search from a specified point onwards
	closeBlockRegex.lastIndex = openBlockEndinPos;

	// And perform the search, if this returns null, it means no match is found.
	// it also means we would need to "auto close" at the end of the document
	let closeBlockMatch = closeBlockRegex.exec( state.src );

	// Lets compute some of the positions we would need
	let closeBlockEndinPos = closeBlockRegex.lastIndex;
	let closeBlockStartPos = closeBlockMatch.index;

	// Lets figure out the last line of the close block
	let lastLine = startLine;
	for(lastLine; lastLine < endLine; ++lastLine) {
		// Increment until the last line is reached
		if( state.eMarks[lastLine] >= closeBlockEndinPos ) {
			break;
		}
	}

	// Note, you still can return false, and exit here, and abort your matching logic
	// and may do so until you actually need to modify the state. For example
	//
	// If this is not official intended behaviour, well there are a few plugins who does this
	// so YMMV =l
	// ---
	// if( closeBlockMatch == null ) {
	// 	return false;
	// }

	//---------------------------------------------------------------------------------------
	//
	// ## Perform STATE MANIPULATION !
	//
	// This is probably the most confusing part, but i will try my best (" -_-)
	//
	//---------------------------------------------------------------------------------------

	// There are two ways to do state manipulation in general 
	// either at the line-by-line level (using the block API)
	// or character-by-character level (using the inline API)
	//
	// Im focusing on inline API, because its more universal

	// First lets get the original position
	let oriPos    = state.pos;
	let oriPosMax = state.posMax;

	// Lets insert a set of "open" token
	// if you implement a new token type, you will need to add a renderer later
	// if you reuse an existing totken type, it will be rendered by an existing renderer
	//
	// For our use case, we will be creating a new token name "hint"

	let token;

	// Generate the token, and store its markup, "1" means it's an opening token
	// state.push("<type>", "<html tag to use>", <open/self-closing/close>);
	token = state.push("hint_open", 'div', 1);
	token.markup = state.src.slice(openBlockStartPos, openBlockEndinPos);
	
	// Lets generate the "inline" token, which from what I understand
	// somehow gets processed recursively?
	token = state.push("inline", "", 0);
	token.content = state.src.slice(openBlockEndinPos, closeBlockStartPos);
	token.children = [];

	// Lets close the block
	token = state.push("hint_close", 'div', -1);
	token.markup = state.src.slice(closeBlockStartPos, closeBlockEndinPos);

	// Reset the state position, to after the current closing block
	state.pos    = closeBlockEndinPos;
	state.line   = lastLine + 1;
	state.posMax = oriPosMax;

	// console.log( state.src.slice(openBlockStartPos, closeBlockEndinPos) );
	console.log( Object.assign({}, state, { src: "" }) );
	// True for success token setup
	// return true;

	return false;
}

function hintblockRender(tokens, idx, options, env, slf) {
	return "";
	// return '<summary><span class="details-marker">&nbsp;</span>' + slf.renderInline(tokens[idx].children, options, env) + "</summary>";
}