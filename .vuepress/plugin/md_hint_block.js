//--------------------------------------------------------------------------------------------
//
// NOTE: Due to the incredible lack of documentation on how to write a markdown-it plugin,
//       code commentry here will be extreamly verbose, to better aid future plugin authors.
//
//       In addition variable naming favours generic discriptions, over multiple potential 
//       use cases (instead of being specific for our use case), to help make the 
//       "aha" moment easier for another author.
//
//       Code ordering is also structured, to make things easier to understand
//       (eg: the module.exports is brought forward instead of being placed last normally)
//
//       Do not treat any guidance here as definitive, I do not represent markdown-it.
//       I am simply guessing, by trial and error & research, to provide something more
//       informative then "try and fork other plugins", for how to make your own plugin.
//
//       See: https://github.com/markdown-it/markdown-it/blob/master/docs/development.md
//
//       In general for a large 99% percentage of use cases, you might find it "easier" 
//       to build ontop of plugin builders, which greatly simplify the process.
//       
//       So please consider using one of the following when possible
//       - https://www.npmjs.com/package/markdown-it-container
//       - https://www.npmjs.com/package/markdown-it-custom-block
//
//       However if your use case does not fit one of the existing "plugin builders", and
//       you have to write effectively your own token parser (which is "hard").
//       This verbose documentation, is here to help you in making your own plugin.
//       (hopefully, or whoever in the future needs to maintain my plugin code)
//
//       Finally, if you can fill in some of the "knowledge gaps" in this file, especially
//       in places where I simply said "dunno", feel free to send a PR.
//
//--------------------------------------------------------------------------------------------

/*************************************************************************************************
 * 
 * markdown-it plugin function, which will add {% hint %} and {% endhint %} blocks support.
 * 
 *************************************************************************************************/
module.exports = (md, pluginOptions) => {

	//##---
	// md : is the markdown-it instance
	//
	// In general most plugin are initialized by calling the function, and providing the
	// markdown-it instance. By design the plugin should not require a dependency on md-it
	// as this instance will be passed into the plugin
	//
	// For example in vuepress 2 it would be something like the following in config.js
	// ```
	// { 
	//    ... // other config.js stuff
	//    extendsMarkdown: (md) => {
	//	    require("custom/md-it/plugin")(md, pluginOptions);
	//    },
	//    ...
	// }
	// ```
	//
	// For example with markdown-it directly
	//
	// ```
	// var md = require('markdown-it')();
	// md.use( require("custom/md-it/plugin"), pluginOptions);
	// ```
	//##---

	// md.block.ruler.before : this register the plugin hook into markdown-it
	//
	// Firstly you have to understand that md-it, does not use an AST tokenizer
	// this is intentional as due to how the "markdown" language is designed, the
	// AST tokenizer can be "overkill" and hard to extend (agreed)
	//
	// If you do not know whats an AST, its alright, its a complex tool we use to 
	// very commonly process most programming language. And we are not using it here.
	//
	// As such, in general its easier to view this as a set of really optimized 
	// "regex-like-rules" functions that was executed line by line.
	// (hopefully this analogy make sense in time)
	//
	md.block.ruler.before(
		// "fence" refers to the markdown-it stage before code blocks are processed
		// many plugins generally hook in before this stage, for some reasons (dunno)
		//
		// see : https://github.com/markdown-it/markdown-it/issues/289
		// for the full list of ruler stages
		//
		// If you want to only do processing after some of the first few stages are processed
		// you can opt for an alternative stage of the process. I suspect "fence" might have been
		// a case of if it aint broke, everyone just kept copy and pasting this stage.
		"fence", 
		// What we name our plugin : hintblock
		"hintblock", 
		// The plugin function that is triggered
		hintblockPlugin, 
		// I have no idea why almost every plugin does this
		// same as stage, im reusing it.
		{ alt: ["paragraph", "reference", "blockquote", "list"] }
	);
	
	//
	// Setup the renderer, to process the tokens generated by the plugin
	// In our example, we will generate 2 tokens, named "hintblock_open", 
	// "hintblock_close". 
	//
	// Strictly speaking, for our use case we could have implemented, without a custom renderer
	// but im adding it here anyway. To properly show how to "use it"
	//
	md.renderer.rules.hintblock_open  = hintblockRender;
	md.renderer.rules.hintblock_close = hintblockRender;
}

//
// In general the plugin function seems to be called once for ever line of the markdown file
// that is not empty whitespace. Or is not "taken by another plugin" function
// (for lack of better words)
//
// These plugin functions are also called "ruler plugins" as the manager for it is called a "ruler"
// (according to the markdown-it docs), to avoid confusion with the "render" plugin (later).
//
// The ruler, and its plugins are suppose to take the markdown string, and convert it into
// "tokens" (similar to AST), these tokens are then converted into the rendered HTML with the
// "render" plugin functions.
// 
// So very vaguely you can think of the following loop occuring, when the ruler plugin is called
// for every markdown file. To get the rough idea whats going on for now.
//
// (the following is definately wrong, actual code is way more complicated,
//  as various plugins can modify the state, do recursion, etc. But it gives a good
//  enough idea on how it would work for most plugins, from their limited point of view)
//
// ```
// let state = { ... state object with various things ... }
// let mdContent = "... raw content from str ..."
//
// // Lets set the state src value
// state.src = mdContent;
//
// // The number of lines to update
// let mdContentArr = mdContent.split("\n");
// let endDocumentLine = mdContentArr.length;
//
// // Final block output
// let blockOutput = [];
//
// // Iterating each line
// for(let startLine=0; startLine<endDocumentLine; startLine++) {
//
//    // Skip blank lines
//    if( mdContentArr[startLine].trim() == "" ) {
//      continue;  
//    }
//
//    // Call the various plugins, including this function,
//    // we will cover silent mode later
//    blockOutput = ruler.callAllThePlugins( state, startLine, endDocumentLine )    
//
//    // Does various complex things to modify the state obj, etc
//    ....
// }
//
// // Convert the blockOutput, into the HTML string
// return renderer.allAllThePlugins( blockOutput );
//
// ```
/**
 * Plugin function for the md-it "ruler" operations
 * 
 * @param {Object}  state obj representing the current markdown process/file
 * @param {int}     startLine number of the line being processed
 * @param {int}     endDocumentLine number of the "file" (or string) being processed
 * @param {boolean} silentValidation flag, if true, function should only return true, or false
 *                  only if it have a relevent starting token. It must not modify if silent.
 *                  (example of how this flag is used is in the function)
 **/
function hintblockPlugin(state, startLine, endDocumentLine, silentValidation) {

	//---------------------------------------------------------------------------------------
	//
	// ## Find out where your line starts (or ends)
	//
	// First, given the startLine, we should extract out the
	// starting character number, and ending character number of the line
	//
	// This can be done using the following values prepopulated by md-it
	//
	// state.bMarks[lineNum] : Character number of "start of line"
	// state.eMarks[lineNum] : Character number of "ending of line"
	// state.tShift[lineNum] : Offset from bMarks, to the first non white-space character,
	//                         this is useful, if your content uses the prefix whitespace
	//                         as some indicator of "level" or "hirachy", if not for most,
	//                         you will add this together with "start of line" value
	//
	//---------------------------------------------------------------------------------------
	let startOfLine = state.bMarks[startLine] + state.tShift[startLine];
	let endinOfLine = state.eMarks[startLine];

	//---------------------------------------------------------------------------------------
	//
	// ## Early return false when possible (or markdown-it will be ssslllooowww...)
	//
	// Typically for "performance", you try to return `false` as soon as possible
	// if you are certain the line does not contain anything relevent to your plugin.
	//
	// In this stage when possible, we avoid heavy regex, and "slicing" for the line
	// string, until we have some indicator that we found a match.
	//
	//---------------------------------------------------------------------------------------

	// For example, we know that "{%", and "%}" is our opening and closing tag for our use case
	// So, lets get the chracter numbers for them, so we can check for them efficently
	//
	// `"{%".charCodeAt(0)`, gives 123
	// `"{%".charCodeAt(1)`, gives 37
	const openChar1 = 123; 
	const openChar2 = 37; 

	// ---
	// IF: your plugin is designed to be only the start of a new line, you can fail quickly
	//     if the desired character is not at the start of the line, return false on the spot.
	//     
	//     However this is not the case for us as of now
	// ---
	// // If it does not match, return false
	// if( state.src.charCodeAt(start) != openChar1 ) {
	//     return false;
	// }
	// ---

	// So alternatively, we scan the line character by character with the openBlockStartPos var,
	// which we will use this for tracking "start of block"
	let openBlockStartPos;

	// We use lastCheckingPos, instead of endinOfline, because at minimum we would need to 
	// match against "{% hint %}", or 10 characters in total.
	//
	// For our use case, we do not allow this block to be split across multiple lines, 
	// if you do so for yours, you may want to check only for the starting 2 characters only. 
	// 
	// If your use case uses a block of only 1 character, its generally considered "bad design"
	// due to the high possibility of triggering it in normal valid text.
	//
	// In our case, if the first of the last 10 character is not a valid match, 
	// we do not need to check against all other remiaing 9 characters.
	let lastValidStartPos = endinOfLine - 10;

	// Note that if lastValidStartPos is < startOfLine (less then 10 characters)
	// it means the line is less then 10 characters, so lets ignore this line for our use case.
	if( lastValidStartPos <= openBlockStartPos ) {
		return false;
	}

	// Lets loop for each character one-by-one
	for(openBlockStartPos=startOfLine; openBlockStartPos<=lastValidStartPos; ++openBlockStartPos) {
		if( state.src.charCodeAt(openBlockStartPos) === openChar1 ) {
			break;
		}
	}

	// If openBlockStartPos is not found within the lastValidStartPos bound. Its either not on the current line at all,
	// or the opening character "{" is in the last 9 characters, and might mean something else and is not 
	// relevent for our use case.
	//
	// If openBlockStartPos <= lastValidStartPos, a match is found
	if( openBlockStartPos > lastValidStartPos ) {
		return false;
	}

	// ---
	// Minor note: The additional 2nd / 3rd char check is not really needed, im just obsessive. 
	//             Most plugin's I seen stop optimizing their early false return with the first
	//             1 or 2 characters as its typically "good enough" I guess  ¯\(o_o)/¯
	//
	//             Its also a good excuse for me to use the md.utils (which is useful to some ppl)
	// ---

	// Lets check the 2nd character, and fail that quickly too if possible
	if( state.src.charCodeAt(openBlockStartPos+1) !== openChar2 ) {
		return false;
	}

	// Lets get the markdown instance
	const md = state.md;

	//
	// Lets check that the 3rd character, for whitespace (for our use case)
	// to avoid needing to figure out the various UTF-8 implemention of whitespaces
	// you can use the provided `md.utils.isWhitespace(charCode)` tool
	//
	// You can find the commands here
	// See: https://github.com/markdown-it/markdown-it/blob/a1c9381/lib/common/utils.js
	//
	// There are also other useful commands on the state object itself here
	// See: https://github.com/markdown-it/markdown-it/blob/a1c9381/lib/rules_block/state_block.js
	//
	if( md.utils.isWhiteSpace( state.src.charCodeAt(openBlockStartPos+2) ) === false ) {
		return false;
	}

	//---------------------------------------------------------------------------------------
	//
	// ## Lets process the opening line (more casually)
	//
	// Now that we have optimized quick false returns in the above, you can now start
	// processing the strings, without the obsession in performance. 
	// (I prefer to make code readable as much as possible)
	//
	// We can be somewhat confident that anything past this line, has a resonably chance
	// of being part of our use case.
	//
	// However, as it is still possible for the line to be not relevent for our use case, 
	// as such we should code defensively to account for such flows.
	//
	//---------------------------------------------------------------------------------------

	// You can get the full line from the first non-whitespace character with the following
	// --- 
	// let markdownLine = state.src.slice(startOfLine, endinOfLine);

	// However we can also opt for a more truncated string (without the opening "{%")
	let markdownLine = state.src.slice(openBlockStartPos+3, endinOfLine)

	// Let's define the opening and closing tokens strings
	// this is used for both the "opening block" and the "closing block"
	// which is "{% hint %}" and "{% endhint %}" respectively
	const openBlock = "{%"
	const closeBracket = "%}"

	// Lets check for closing token, if its not found. We return false once again
	let openBlockCloseTokenOffset = markdownLine.indexOf(closeBracket);
	if( openBlockCloseTokenOffset <= 0 ) {
		// No match, exit
		return false;
	}

	// Ok we finally found a valid starting and closing pair, 
	// lets get the opening block inner string
	let openBlockStr = markdownLine.slice(0, openBlockCloseTokenOffset).trim();

	// While our blocks can support multiple parameters
	// what is more critical is that our first word starts with "hint" for our use case
	let openBlockStrArr = openBlockStr.split(/[\s]+/);
	if( openBlockStrArr[0].toLowerCase() !== "hint" ) {
		return false;
	}

	//---------------------------------------------------------------------------------------
	//
	// ## Lock in, and handle silent flag
	//
	// Now that we are absolutely sure that the line presented to us is relevent.
	// with proper opening and closing bracker for the opening block.
	//
	// We will report success, if the silentValidation flag is set to true.
	//
	// Assumingly, after reporting true, the function will be called again to perform
	// the actual state processing. And only then will we be allowed to modify states.
	//
	// Some plugin documentation seems to imply supporting this is optional
	// but I could not find any means, to safely "not support" this behaviour.
	//
	// So make sure to add the check i suppose.
	//
	// ¯\(o_o)/¯
	//
	//---------------------------------------------------------------------------------------

	// Exit with success, if its in silent validation mode.
	// Everything after here will involve state manipulation
	if( silentValidation ) {
		return true;
	}

	//---------------------------------------------------------------------------------------
	//
	// ## Process opening block parameters
	//
	//---------------------------------------------------------------------------------------

	// lets compute the openBlockCloseTokenPos, for the "%" character in the opening "%}" block
	let openBlockCloseTokenPos = openBlockStartPos+3+openBlockCloseTokenOffset;

	// and the open block ending pos (after the %} characters)
	let openBlockEndinPos = openBlockCloseTokenPos+2;

	// Lets also process the opening block "parameters"
	let openBlockParam = {};
	for(let i=1; i<openBlockStrArr.length; ++i) {
		let pair = openBlockStrArr[i].split("=")
		let key = pair[0];
		let value = pair[1];

		// Just register true, if no value is provided
		if( value == null ) {
			openBlockParam[key] = true;
			continue;
		}

		// Lets cleanup any starting or ending quotes
		while( value.startsWith('"') || value.startsWith("'") ) {
			value = value.slice(1);
		}
		while( value.endsWith('"') || value.endsWith("'") ) {
			value = value.slice(0, value.length - 1);
		}
		// And save the value
		openBlockParam[key] = value;
	}
	
	//---------------------------------------------------------------------------------------
	//
	// ## Find the closing block set 
	//
	// Lets find the closing block set, if its not found, we will presumingly just
	// use all remaining lines as the "summary" block between the opening and closing.
	//
	//---------------------------------------------------------------------------------------

	// ---
	// NOTE: how to deal with the closing block search is very "use case sensitive"
	//
	//       There is a resonable chance the logic here does not fit your use case.
	//       if so, figure out how to get the closing block position "on your own",
	//       and use this codebase as a refrence on what to do after that.
	// ---

	//
	// Closing block regex, this is used to find our {% endhint %} block
	//
	// /                     # - Start of regex
	// (                     # - Opening capture group 1
	//   \{\%                # - Match "{%"
	//   [\s]+               # - Match any number of white space
	//   endhint             # - Match "endhint " including an ending whitespace
	//   [\s]+               # - Match any number of white space
	//   [.]*                # - Match any random parameters which would ignore
	//                       #   ( Eg: "param=xyz %}" )
	//   \%\}                # - Match "%}" 
	// )                     # - Closing capture group 1
	// /img                  # - End of regex, indicated as case insensitive, 
	//                       #   multi-line, and global match
	//
	const closeBlockRegex = /(\{\%[\s]+endhint[\s]+[.]*\%\})/img;

	// ---
	// I added the following "nextLine" loop here, as a large number of plugin's performs this
	// action in one way or another, due to the requirements of their use case.
	//
	// This might be useful for you, if needed. It isn't in my current use case.
	// ---
	/***
	// Lets start iterating all the lines from here onwards hopefully its in an early line block
	let nextLine = startLine;
	for(nextLine; nextLine < endDocumentLine; nextLine++) {

		// Lets get start and max of line
		let start = state.bMarks[nextLine] + state.tShift[nextLine];
		let max = state.eMarks[nextLine];

		// Lets skip to "after" the current block for first line
		//
		// this makes sense for oru use case, it may not make sense for use cases
		// where multiple lines is a gurantee.
		if( nextLine == startLine ) {
			start = openBlockEndinPos;
		}

		// Get the line string, if possible code your check to avoid this 
		// (slice in a loop is expensive)
		let lineStr = state.src.slice(start, max)

		// .... Do matching logic ???
		let match = lineStr.match( closeBlockRegex )

		// .... More matching logic ???
	}
	***/

	// ---
	// Instead I opt to do the following with RegExp
	// ---

	// Modify the RegExp "lastIndex", to begin a search from a specified point onwards
	closeBlockRegex.lastIndex = openBlockEndinPos;

	// And perform the search, if this returns null, it means no match is found.
	// it also means we would need to "auto close" at the end of the document
	let closeBlockMatch = closeBlockRegex.exec( state.src );

	// Prepare ending position calculations (if found)
	let closeBlockEndinPos = null;
	let closeBlockStartPos = null; 

	// If no match was found, the last line will be "end of document"
	let lastLine = endDocumentLine;
	
	// Lets compute some of the positions we would need
	// (only valid if a match was found)
	if( closeBlockMatch != null ) {
		closeBlockEndinPos = closeBlockRegex.lastIndex;
		closeBlockStartPos = closeBlockMatch.index;
	
		// Lets figure out the last line of the close block
		for(lastLine = startLine; lastLine < endDocumentLine; ++lastLine) {
			// Increment until the last line is reached
			if( state.eMarks[lastLine] >= closeBlockEndinPos ) {
				break;
			}
		}
	}

	// Note, you still can return false, and exit here, and abort your matching logic
	// and may do so until you actually need to modify the state. For example
	//
	// If this is not official intended behaviour, well there are a few plugins who does this
	// so YMMV =l
	// ---
	// if( closeBlockMatch == null ) {
	// 	return false;
	// }

	//---------------------------------------------------------------------------------------
	//
	// ## Perform STATE MANIPULATION !
	//
	// This is probably the most confusing part, but i will try my best (" -_-)
	//
	//---------------------------------------------------------------------------------------

	// We will be resuing some variables a fair bit, so lets initilaize them

	let token; // The token we are currently setting up
	let content; // Content string, where applicable

	// ---
	// In general you modify the state, by generating your relevent tokens,
	// and inserting them into the state list. 
	//
	// Once you have processed such lines, you should also move "the state forward", 
	// so that the next processor who picks up the next lines will skip processing,
	// the lines you have processed.
	// ---

	//##---
	//## 1) we will process any text "before" the {% hint %} token
	//##---
	
	// For a vast majority of "block" processor this step is not needed, as typically
	// by design, their blocks are meant to be the start of the line. Note we only,
	// process the text, if we they are present (and skip if they are not)
	//
	// This condition is only try if {% hint %} was not the start of the line
	if( startOfLine < openBlockStartPos ) {
		content = state.src.slice( startOfLine, openBlockStartPos ).trim();
		if( content.length > 0 ) {
			// Lets setup an "inline" block, which will be revaluated for any markup
			// this is probably using an inbuilt "inline" block processor (somewhere)
			//
			// The "inline" block is an existing predefined block type
			// which basically revaluates itself recursively.
			token = state.push("inline", "", 0);

			// The content to render inline
			token.content = content;

			// Child nodes will be processed and initialized inside here, using the "content"
			token.children = [];

			// The lines affected by this block, not sure if 
			// this actually has any purpose other then documentation ?
			token.map = [startLine, startLine];
		}
	}

	//##---
	//## 2) We then Generate the opening hint block
	//##---

	// Generate the token, and store its markup, where we will increase its block level by 1
	// using an opening token.
	// ---
	// state.push("<type>", "<html tag to use>", <open:1/self-closing:0/close:-1>);

	// We set this up using our new "type", which will map to the renderer (later)
	// note that if you do not need to "modify" the tag used, you would not need a custom renderer
	//
	// If you need custom attributes, you could also just add it to the existing HTML block
	// `token.attrs = { class: "classname" }`
	//
	// The default renderer, will simply open/close with the given HTML block
	token = state.push("hintblock_open", "div", 1);

	// We provide the raw markup, this is really just common convention (we dun use it)
	token.markup = state.src.slice(openBlockStartPos, openBlockEndinPos);

	// And the line numbers it affects (optional)
	token.map = [startLine, startLine];
	
	// You can additionally, fill it up with additional custom data,
	// which can be used by your renderer (unique to your use case)
	token.meta = { openBlockParam: openBlockParam, type:"open" };
	
	//##---
	//## 3) And process all the inline content (between {% hint %} and {% endhint %})
	//##---

	// Once again we recursively process the markdown content using the inline block
	token = state.push("inline", "", 0);
	token.content = state.src.slice(openBlockEndinPos, closeBlockStartPos);
	token.children = [];
	token.map = [startLine, lastLine];

	//##---
	//## 4) With the closing block once again
	//##---

	// We have two major scenerios, 
	// one where the closing block is found, another when there is none
	//
	// However not much needs to be done here, as lastLine is already normalized
	// to handle this use case to the last line of the document, if the block is not found.

	token = state.push("hintblock_close", "div", -1);
	token.map = [lastLine, lastLine];
	token.meta = { type:"close" };

	if( closeBlockMatch != null ) {
		// We have a closing block, lets return its markup
		token.markup = state.src.slice(closeBlockStartPos, closeBlockEndinPos);
	} else {
		// No markup, no cry
		token.markup = "";
	}
	
	//##---
	//## 5) Followed by any trailing inline text content after {% endhint %}
	//##---
	if( closeBlockMatch != null && closeBlockEndinPos < state.eMarks[lastLine] ) {
		content = state.src.slice( closeBlockEndinPos, state.eMarks[lastLine] ).trim();
		if( content.length > 0 ) {
			
			// Hello inline block once again, you are so useful in gluing things together
			token = state.push("inline", "", 0);
			token.content = content;
			token.children = [];
			token.map = [lastLine, lastLine];
		}
	}

	//---------------------------------------------------------------------------------------
	//
	// ## Cleanup and return
	//
	//---------------------------------------------------------------------------------------

	// Finally, we update the state line, to the "next line",
	// so that the next processor, will start only from the next line onwards,
	// preventing several possible infinite loop events
	state.line   = lastLine + 1;
	
	// True for success token setup, to apply your changes to the state object
	// False will prevent your changes from being applied (somehow?)
	return true;
}

//
// Now that you have all your "tokens" generated, lets hook the renderer's for those custom blocks
//
// The renderer will be called multiple times, for each block.
//
// PS: While you can implement individual renderer, for opening and closing blocks. 
//     I decided to just use one for this example.
//
/**
 * Plugin renderer for the md-it "renderer" operations
 * 
 * @param {Array}   tokenArr array of tokens being processed
 * @param {int}     idx of the array that is being processed
 * @param {Object}  options : dunno
 * @param {Object}  env     : dunno
 * @param {Object}  slf     : dunno, im guessing this is the markdown instance
 * 
 * @return HTML string to be rendered
 **/
function hintblockRender(tokenArr, idx, options, env, slf) {

	// Note: if your block contains "content" and "children" nodes, you can render using the following convinently
	// ---
	// slf.renderInline(tokens[idx].children, options, env)

	// Lets get the token we are supposed to process
	let token = tokenArr[idx];

	// Lets handle opening or closing respectively
	if( token.meta.type == "open" ) {
		// Our default block type is "tip", for vuepress
		let containerTyper = "tip";

		// Lets get the block param
		let blockParam = token.meta.openBlockParam;
		let style = blockParam.style;

		// While its not one to one, we can loosely map most of the common style types to vue press 2 equivalent
		// This is unique to our use case if its not obvious (not related to markdown-it)
		//
		// See: https://v2.vuepress.vuejs.org/reference/default-theme/markdown.html#custom-containers
		if( style == "info" || style == "success" ) {
			containerTyper = "tip";
		} else if( style == "warning" ) {
			containerTyper = "warning";
		} else if( style == "danger" ) {
			containerTyper = "danger";
		} else if( style == "details" ) {
			containerTyper = "details";
		}

		// Lets generate the opening container, without title
		let retStr = `<div class="custom-container ${containerTyper} hint hint-${style}">`

		// Include the custom title if its provided
		if( blockParam.title ) {
			retStr += `<p class="custom-container-title">${blockParam.title}</p>`
		}
		
		// Notice, that because im just customizing attributes for simple HTML objects
		// I could have implemented all of these, without a custom renderer, and use the 
		// default renderer with the "attrs"-ibute parameter.

		// return the finished str
		return retStr;
	} else {
		// Closing block is straight forward, just close the div
		return "</div>"
	}
}